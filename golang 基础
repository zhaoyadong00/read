1.变量
	声明：标准格式 var 变量名 变量类型
	批量格式：var (
		a int
		b string
		c []string
		d func() bool
		e struct {
			x int
		}
	)
1.1初始化
	var 变量名 变量类型 = 表达式
	var hp int = 9
	var hp = 9 编译器会推导变量的的类型
	hp := 9
	var a int = 100
	var a , b , c = 1,2,3

1.2 数据类型
	整型，浮点型，布尔型，字符串 字符 切片 map 结构体 函数 通道
	整型：int8 int16 int32 int64
		uint8 uint16 uint32 uint64
	浮点型：float32 float64
	布尔型：true false
	字符串：var a = "abx"
	字符：byte uint8
	切片：[]byte by := make([]byte , 10)

1.3 指针
	a := 9
	b := &a
	*b = 15
	fmt.Println(a , *b , b)
	//15 15 0xc00005c068
	*a 指针类型
	func (a *int)int{
		return *a
	}
1.4 创建指针的另外一种办法 new
	s := new(string)
	fmt.Println(s)
	*s = "123"
	fmt.Println(s , *s)
	//0xc0000321f0
	//0xc0000321f0 123
1.5 变量的生命周期
	栈：是一种拥有特殊规则的线性表数据结构
	栈只允许往线性表的一端放入数据，之后从另一端取出数据 按照后进先出的顺序
	理解：栈的原理类似于将书一本本的堆起来 书按顺序一本本的从顶部放入 要去书市只能从顶部一本本的取出

	堆：就像房子里面摆家具会形成内存碎片

	go自动识别变量是分配到堆上 还是分配到栈上
1.6 字符串应用
	len(string) 获取字符串的长度
	遍历ascll码字符串直接使用下标
	Unicode字符串遍历使用for range
	s := "encode to string !!!"
	bs := base64.StdEncoding.EncodeToString([]byte(s))
	s1 , err := base64.StdEncoding.DecodeString(bs)
	fmt.Println(s , bs , string(s1) , err)
	//encode to string !!! ZW5jb2RlIHRvIHN0cmluZyAhISE= encode to string !!! <nil>
	读取文件
	file , err := os.Open(filename)
	if err != nil {
		return 
	}
	defer file.close
	fmt.Println(file)
	reader := bufio.NewReader(file)
	for{
		linestr , err := reader.ReadString('\n')
		if err != nil {
			break
		}

	}
1.7 常量
	相对于变量，常量是很定不变的值
	枚举
	const （
		a = iota
		b
		c
		d
	）
1.8 类型别名
	1.9之前 type byte uint8
			type rune int32
	1.9之后 type byte = uint8
			type rune = int32

	类型定义与区分类型别名
		type typeAlias = type //别名

		type NewInt int //定义类型

		type IntAlias = int //定义int的别名

		var a NewInt

		var b IntAlias

		fmt.Printf("a type : %T\n b type : %T\n" , a , b)
		//a type : NewInt
		//b type int

2.1 数组-固定大小的连续空间
	2.1.1 声明数据
		var 数组变量名 [元素个数]元素类型
		var ints [3]int

	2.1.2 初始化数组
		var ints = [3]int{1,2,3}
		var ints = [...]int{1}//定义不固定数量元素的数组

	2.1.3 遍历数组
		for k , v := range ints {
			fmt.Println( k , v)
		}


	2.2.1 切片 -- 动态分配大小的连续空间
		2.2.1从数组或切片生成新的切片
		slice[开始位置:结束位置]
		var s [3]string//定义变量 但是未初始化
		var s1 = [3]string{"1" , "2" , "3"}//定义数组变量并初始化
		//生成新的切片
		s2 := s1[1:2]
		s3 := s1[1:3]
		fmt.Println(s , s1 , s2 , s3)
		//[  ] [1 2 3] [2] [2 3]
		s4 := s1[:]//表示原有切片
		s5 := s1[0:0]//重置切片
	2.2.2 切片的声明
		var name []T
		//声明字符串切片
		var s1 []string
		//声明整型切片
		var s2 []int

		var s1 []string
		fmt.Println(s1)
		s1 = append(s1 , "aaa")
		fmt.Println(s1)
		//[]
		//[aaa]

	2.2.3 使用make（）函数构造切片
		格式：make([]int , size , cap)
		T 切片的元素类型
		size 为这个类型分配多少个元素
		cap 预分配元素数量 这个值的设定不影响size 只是提前分配空间 降低多次分配空间造成的性能问题

		a := make([]int , 10)
		b := make([]int , 10 , 1024)

	2.2.4 使用append函数为切片添加元素
		s1 := make([]int , 10)
		s2 := make([]int , 5)
		s1 = append(s1 , 12)
		fmt.Println(s1)
		s1 = append(s1 , s2...)
		fmt.Println(s1)
		//[0 0 0 0 0 0 0 0 0 0 12]
		//[0 0 0 0 0 0 0 0 0 0 12 0 0 0 0 0]
	2.2.5 切片的复制
		copy（destSlice , srcSlice[]T）int

	2.2.6 切片元素的删除
		s1 := []int{1,2,3,4,5,6,7,8,9}

		//删除3
		fmt.Println(append(s1[0:2] , s1[3:]...))
		//[1 2 4 5 6 7 8 9]

2.3映射 map
	map使用散列hash实现
	2.3.1 map的添加与访问数据
		map[T]T
		var m map[int]int//定义m变量 但是未实例化 不可使用//panic: assignment to entry in nil map
		var m = map[int]int{1:1} //定义变量并且初始化
		m[1] = 2
		fmt.Println(m)
		//map[1:2]
		var m = make(map[int]int , 10)
		m[1] = 21
		fmt.Println(m)
		//map[1:21]
	2.3.2 遍历map键值对
		for k , v := range m {
			fmt.Println(k , v)
		}
	2.3.3 使用delete函数 删除map键值对
		m := delete(m , 1)
		fmt.Println(m)
		//map[]
	2.3.4 清空map
		m = make(map[] , 0)//新建一个map 赋值给m 清空了原来的数据
	2.3.5 并发环境中使用map -- sync.map
		var m sync.Map
		m.Store(1 , 21)
		m.Store(2 , 21)
		m.Store(3 , 21)
		fmt.Println(m)
		m.Delete(1)
		fmt.Println(m)
		fmt.Println(m.Load(2))
		fmt.Println(m.LoadOrStore(5 , 43))
		m.Range(func(key, value interface{}) bool {
			fmt.Println(key , value)
			return true
		})
		//{{0 0} {{map[] true}} map[1:0xc00008a018 2:0xc00008a020 3:0xc00008a028] 0}
		//{{0 0} {{map[] true}} map[2:0xc00008a020 3:0xc00008a028] 0}
		//21 true
		//43 false
		//5 43
		//2 21
		//3 21

2.4 列表 list
	






